<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: Simple Threading and Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Simple Threading and Communication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://durandaltheta.github.io/sthread/">Documentation</a></p>
<p><a href="tst/simple_thread_tst.cpp">Unit Test and Example Code</a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Purpose</h1>
<p>This header only library seeks to easily setup useful worker threads using a simple API.</p>
<p>Instead of functions worker threads execute c++ functors. A functor is a class which has a function call overload allowing you to execute the object like a function, IE: </p><div class="fragment"><div class="line">struct MyClass {</div>
<div class="line">    inline void operator()(std::shared_ptr&lt;st::message&gt; msg) { /* ... */ }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Functors (as used by this library) have several advantages over raw functions.</p><ul>
<li>The worker thread message receive loop is managed by the library</li>
<li>The worker lifecycle is managed by the library</li>
<li>Sending messages to the worker is provided by the library</li>
<li>Functors allow for inheritance</li>
<li>Functors allow for public enumerations and child classes to be defined as part of its namespace, which is useful for organizing what messages and message payload data types the thread will listen for.</li>
<li>Functors allow for class method definitions, instead of forcing the user to rely on lambdas, local objects or global namespace functions if further function calls are desired.</li>
<li>Initialization (constructor), runtime execution (<code>void operator()(std::shared_ptr&lt;<a class="el" href="structst_1_1message.html" title="Interthread type erased message container.">st::message</a>&gt;</code>), and deinitialization (destructor) are broken in to separate functions, which I think makes them more readable. A thread running only a raw function requires everything be managed within that function.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Requirements</h1>
<ul>
<li>C++11</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Git Submodules</h1>
<p>This project uses Googletest as a submodule to build unit tests. If unit tests are needed try cloning this project with submodules:</p><ul>
<li>git clone &ndash;recurse-submodules <a href="https://github.com/durandaltheta/sthread">https://github.com/durandaltheta/sthread</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Installation</h1>
<ul>
<li>cmake .</li>
<li>sudo make install <br  />
</li>
</ul>
<p>Alternatively just copy the .h files in inc/ folder to your local project headers and include as normal.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Build Unit Tests</h1>
<ul>
<li>cmake .</li>
<li>make simple_thread_tst</li>
</ul>
<p>simple_thread_tst binary will be placed in tst/</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Usage</h1>
<ul>
<li>Install the library and include the header <code>sthread</code> or <code><a class="el" href="simple__thread_8hpp.html" title="Simple interprocess threading and messaging.">simple_thread.hpp</a></code></li>
<li>Create a class or struct with <code>void operator()(std::shared_ptr&lt;<a class="el" href="structst_1_1message.html" title="Interthread type erased message container.">st::message</a>&gt;)</code> to handle received messages (also called a 'functor')</li>
<li>Define some enum to distinguish different messages</li>
<li>Launch your thread with <code><a class="el" href="structst_1_1worker.html#a4ab1891f3a52bc05871caa1e4f0b55af">st::worker::make</a>&lt;YourClassNameHere&gt;()</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Basic Usage</h2>
<h3><a class="anchor" id="autotoc_md8"></a>
Example 1:</h3>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">struct MyClass {</div>
<div class="line">    enum op {</div>
<div class="line">        hello,</div>
<div class="line">        world</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    inline void operator()(std::shared_ptr&lt;st::message&gt; msg) {</div>
<div class="line">        switch(msg-&gt;id()) {</div>
<div class="line">            case op::hello:</div>
<div class="line">                std::cout &lt;&lt; &quot;hello &quot; &lt;&lt; std::endl;</div>
<div class="line">                break;</div>
<div class="line">            case op::world:</div>
<div class="line">                std::cout &lt;&lt; &quot;world&quot; &lt;&lt; std::endl;</div>
<div class="line">                break;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::shared_ptr&lt;st::worker&gt; my_worker = st::worker::make&lt;MyClass&gt;();</div>
<div class="line"> </div>
<div class="line">    my_worker-&gt;send(MyClass::op::hello);</div>
<div class="line">    my_worker-&gt;send(MyClass::op::world);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">hello world</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Message Payload Data</h2>
<p>Message data payloads can be of any type and can be copied to argument <code>T t</code> with <code><a class="el" href="structst_1_1message.html#a712cfd7aa3954f29645561f4e29a4af3">st::message::copy_data_to</a>&lt;T&gt;(T&amp;&amp; t)</code> or rvalue swapped with <code><a class="el" href="structst_1_1message.html#a8cfc67f035589432aefcb8d5a8da7b83">st::message::move_data_to</a>&lt;T&gt;(T&amp;&amp; t)</code>.</p>
<p><code><a class="el" href="structst_1_1message.html#a712cfd7aa3954f29645561f4e29a4af3">st::message::copy_data_to</a>&lt;T&gt;(T&amp;&amp; t)</code> and <code><a class="el" href="structst_1_1message.html#a8cfc67f035589432aefcb8d5a8da7b83">st::message::move_data_to</a>&lt;T&gt;(T&amp;&amp; t)</code> will return <code>true</code> only if the stored payload type matches type <code>T</code>, otherwise it returns <code>false</code>. </p>
<h3><a class="anchor" id="autotoc_md10"></a>
Example 2:</h3>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">struct MyClass {</div>
<div class="line">    enum op {</div>
<div class="line">        print</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    inline void operator()(std::shared_ptr&lt;st::message&gt; msg) {</div>
<div class="line">        switch(msg-&gt;id()) {</div>
<div class="line">            case op::print:</div>
<div class="line">            {</div>
<div class="line">                std::string s;</div>
<div class="line">                if(msg-&gt;copy_data_to(s)) {</div>
<div class="line">                    std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line">                break;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::shared_ptr&lt;st::worker&gt; my_worker = st::worker::make&lt;MyClass&gt;();</div>
<div class="line"> </div>
<div class="line">    std::string s(&quot;hello again&quot;);</div>
<div class="line">    my_worker-&gt;send(MyClass::op::print, s);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">hello again</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Payload Type Checking</h2>
<p>Payload types can also be easily checked with <code><a class="el" href="structst_1_1message.html#a23536bf1bda738b333fc6723c8502eb0">st::message::is</a>&lt;T&gt;()</code> (returns <code>true</code> if types match, else <code>false</code>) which is useful if a message might contain several different potential types.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Example 3:</h3>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">struct MyClass {</div>
<div class="line">    enum op {</div>
<div class="line">        print</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    inline void operator()(std::shared_ptr&lt;st::message&gt; msg) {</div>
<div class="line">        switch(msg-&gt;id()) {</div>
<div class="line">            case op::print:</div>
<div class="line">                if(msg-&gt;is&lt;std::string&gt;()) {</div>
<div class="line">                    std::string s;</div>
<div class="line">                    msg-&gt;copy_data_to(s);</div>
<div class="line">                    std::cout &lt;&lt; s;</div>
<div class="line">                } else if(msg-&gt;is&lt;int&gt;()) {</div>
<div class="line">                    int i = 0;</div>
<div class="line">                    msg-&gt;copy_data_to(i);</div>
<div class="line">                    std::cout &lt;&lt; i;</div>
<div class="line">                }</div>
<div class="line">                break;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::shared_ptr&lt;st::worker&gt; my_worker = st::worker::make&lt;MyClass&gt;();</div>
<div class="line"> </div>
<div class="line">    std::string s(&quot;hello &quot;);</div>
<div class="line">    my_worker-&gt;send(MyClass::op::print, s);</div>
<div class="line">    int i = 1;</div>
<div class="line">    my_worker-&gt;send(MyClass::op::print, i);</div>
<div class="line">    s = &quot; more time\n&quot;;</div>
<div class="line">    my_worker-&gt;send(MyClass::op::print, s);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">hello 1 more time</div>
</div><!-- fragment --><p><code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code>s will automatically shutdown and join when they are destructed. This can be done early with <code><a class="el" href="structst_1_1worker.html#a3f98d0479ad642ed572fd723caeb893d" title="Shutdown the worker thread.">st::worker::shutdown()</a></code>. <code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code>s can also be restarted at any time with <code><a class="el" href="structst_1_1worker.html#a2e3f89739083c6d6779712081d30d459" title="Restart the worker thread.">st::worker::restart()</a></code>. See <a href="https://durandaltheta.github.io/sthread/">documentation</a> for more info.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Worker Constructor Arguments and Lifecycle</h2>
<p><code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code>s can be passed constructor arguments in <code><a class="el" href="structst_1_1worker.html#a4ab1891f3a52bc05871caa1e4f0b55af">st::worker::make</a>&lt;FUNCTOR&gt;(As&amp;&amp;...)</code>. The <code>FUNCTOR</code> class will be created on the new thread and destroyed before said thread ends.</p>
<p>An <code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code>'s <code>std::thread</code> will be shutdown and joined when any of the following happens:</p><ul>
<li>The <code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code>s last <code>std::shared_ptr</code> goes out of scope</li>
<li><code><a class="el" href="structst_1_1worker.html#a3f98d0479ad642ed572fd723caeb893d" title="Shutdown the worker thread.">st::worker::shutdown()</a></code> is called on a worker</li>
<li><code><a class="el" href="structst_1_1worker.html#a2e3f89739083c6d6779712081d30d459" title="Restart the worker thread.">st::worker::restart()</a></code> is called on a worker (and a new <code>std::thread</code> and <code>FUNCTOR</code> will be created before <code>restart()</code> returns)</li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
Example 4</h3>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">struct MyClass {</div>
<div class="line">    MyClass(std::string constructor_string, std::string destructor_string) :</div>
<div class="line">        m_destructor_string(destructor_string)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;:&quot; &lt;&lt; constructor_string &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~MyClass() {</div>
<div class="line">        std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;:&quot; &lt;&lt;  m_destructor_string &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    inline void operator()(std::shared_ptr&lt;st::message&gt; msg) { }</div>
<div class="line"> </div>
<div class="line">    std::string m_destructor_string;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;:&quot; &lt;&lt;  &quot;parent thread started&quot; &lt;&lt; std::endl;</div>
<div class="line">    std::shared_ptr&lt;st::worker&gt; wkr = st::worker::make&lt;MyClass&gt;(&quot;hello&quot;, &quot;goodbye&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">0x800018040:parent thread started</div>
<div class="line">0x800098150:hello</div>
<div class="line">0x800098150:goodbye</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Abstracting Message Passing Details</h2>
<p>One useful advanced design pattern is abstracting all of the operation details for message passing into some API, freeing the user from having to interact directly with the thread details.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Example 5:</h3>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">struct MyClass {</div>
<div class="line">    static inline MyClass make() {</div>
<div class="line">        return MyClass(st::worker::make&lt;Worker&gt;());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    inline void set_string(std::string txt) {</div>
<div class="line">        m_wkr-&gt;send(op::eset_string, txt);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    inline std::string get_string() {</div>
<div class="line">        auto ret_ch = st::channel::make();</div>
<div class="line">        m_wkr-&gt;send(op::eget_string, ret_ch);</div>
<div class="line">        std::string s;</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; msg;</div>
<div class="line">        ret_ch-&gt;recv(msg);</div>
<div class="line">        msg-&gt;copy_data_to(s);</div>
<div class="line">        return s;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    enum op {</div>
<div class="line">        eset_string,</div>
<div class="line">        eget_string</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct Worker { </div>
<div class="line">        inline void operator()(std::shared_ptr&lt;st::message&gt; msg) {</div>
<div class="line">            switch(msg-&gt;id()) {</div>
<div class="line">                case op::eset_string:</div>
<div class="line">                    msg-&gt;copy_data_to(m_str);</div>
<div class="line">                    break;</div>
<div class="line">                case op::eget_string:</div>
<div class="line">                {</div>
<div class="line">                    std::shared_ptr&lt;st::channel&gt; ret_ch;</div>
<div class="line">                    if(msg-&gt;copy_data_to(ret_ch)) {</div>
<div class="line">                        ret_ch-&gt;send(0,m_str);</div>
<div class="line">                    }</div>
<div class="line">                    break;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        std::string m_str;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    MyClass(std::shared_ptr&lt;st::worker&gt; wkr) : m_wkr(wkr) { }</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;st::worker&gt; m_wkr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    MyClass my_class = MyClass::make();</div>
<div class="line">    my_class.set_string(&quot;hello&quot;);</div>
<div class="line">    std::cout &lt;&lt; my_class.get_string() &lt;&lt; std::endl;</div>
<div class="line">    my_class.set_string(&quot;hello hello&quot;);</div>
<div class="line">    std::cout &lt;&lt; my_class.get_string() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">hello</div>
<div class="line">hello hello</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Channels</h2>
<p>The object that <code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code>s use for communication in their <code>send()</code> methods is called <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code>. <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code>s can be created and used outside of <code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code> objects if desired.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Example 6:</h3>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">struct MyClass {</div>
<div class="line">    enum op {</div>
<div class="line">        forward</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    MyClass(std::shared_ptr&lt;st::channel&gt; fwd_ch) : m_fwd_ch(fwd_ch) { }</div>
<div class="line"> </div>
<div class="line">    inline void operator()(std::shared_ptr&lt;st::message&gt; msg) {</div>
<div class="line">        switch(msg-&gt;id()) {</div>
<div class="line">            case op::forward:</div>
<div class="line">                m_fwd_ch-&gt;send(msg);</div>
<div class="line">                break;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;st::channel&gt; m_fwd_ch;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::shared_ptr&lt;st::channel&gt; my_channel = st::channel::make();</div>
<div class="line">    std::shared_ptr&lt;st::worker&gt; my_worker = st::worker::make&lt;MyClass&gt;(my_channel);</div>
<div class="line"> </div>
<div class="line">    my_worker-&gt;send(MyClass::op::forward, std::string(&quot;forward this string&quot;));</div>
<div class="line">    </div>
<div class="line">    std::shared_ptr&lt;st::message&gt; msg;</div>
<div class="line">    my_channel-&gt;recv(msg);</div>
<div class="line"> </div>
<div class="line">    std::string s;</div>
<div class="line">    if(msg-&gt;copy_data_to(s)) {</div>
<div class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">forward this string</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Close, Shutdown, and Restart</h2>
<p>In looping <code><a class="el" href="structst_1_1channel.html#a789de5ce12c798c90d6773085e275f35" title="Receive a message over the channel.">st::channel::recv()</a></code> operations <code><a class="el" href="structst_1_1channel.html#ae2a319160262483ed2e290d81390c456" title="Close the channel.">st::channel::close()</a></code> can be manually called to force all operations to cease on the <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> (operations will return <code>false</code>). The default behavior for <code><a class="el" href="structst_1_1channel.html#ae2a319160262483ed2e290d81390c456" title="Close the channel.">st::channel::close()</a></code> is to cause all current and future all <code><a class="el" href="structst_1_1channel.html#a2acf1a19224571f235913014841b0684">st::channel::send()</a></code> operations to fail early but to allow <code><a class="el" href="structst_1_1channel.html#a789de5ce12c798c90d6773085e275f35" title="Receive a message over the channel.">st::channel::recv()</a></code> to continue succeeding until the internal message queue is empty.</p>
<p>This is the default behavior of several functions:</p><ul>
<li><code><a class="el" href="structst_1_1channel.html#ae2a319160262483ed2e290d81390c456" title="Close the channel.">st::channel::close</a>(/* default true */)</code></li>
<li><code><a class="el" href="structst_1_1worker.html#a3f98d0479ad642ed572fd723caeb893d" title="Shutdown the worker thread.">st::worker::shutdown</a>(/* default true */)</code></li>
<li><code><a class="el" href="structst_1_1worker.html#a2e3f89739083c6d6779712081d30d459" title="Restart the worker thread.">st::worker::restart</a>(/* default true */)</code></li>
</ul>
<p>Alternatively, the user can call said functions with explicit <code>false</code> to immediately end all operations on the channel:</p><ul>
<li><code>st::channel::close(false)</code></li>
<li><code>st::worker::shutdown(false)</code></li>
<li><code>st::worker::restart(false)</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md20"></a>
Example 7:</h3>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">void looping_recv(std::shared_ptr&lt;st::channel&gt; ch) {</div>
<div class="line">    std::shared_ptr&lt;st::message&gt; msg;</div>
<div class="line"> </div>
<div class="line">    while(ch-&gt;recv(msg)) {</div>
<div class="line">        std::string s;</div>
<div class="line">        if(msg-&gt;copy_data_to(s)) {</div>
<div class="line">            std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;thread done&quot; &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::shared_ptr&lt;st::channel&gt; my_channel = st::channel::make();</div>
<div class="line">    std::thread my_thread(looping_recv, my_channel);</div>
<div class="line">    std::shared_ptr&lt;st::message&gt; msg;</div>
<div class="line"> </div>
<div class="line">    my_channel-&gt;send(0, std::string(&quot;You say goodbye&quot;));</div>
<div class="line">    my_channel-&gt;send(0, std::string(&quot;And I say hello&quot;));</div>
<div class="line"> </div>
<div class="line">    my_channel-&gt;close(); // end thread looping </div>
<div class="line">    my_thread.join(); // join thread</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">You say goodbye</div>
<div class="line">And I say hello</div>
<div class="line">thread done </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
States and Finite State Machine</h2>
<p>This library provides a fairly simple finite state machine (FSM) implementation as a design tool.</p>
<p>The reasoning for including this feature in the library is that asynchronous programming can have complex state management. Simplifying designs with a state machine can <em>sometimes</em> be advantagous, when used intelligently and judiciously.</p>
<p>The state machine object type is <code><a class="el" href="structst_1_1state_1_1machine.html">st::state::machine</a></code>, which can register new state transitions with calls to <code><a class="el" href="structst_1_1state_1_1machine.html#ae2281d9b0422dc3ea4aabe375bab6024" title="Register a state object to be transitioned to when notified of an event.">st::state::machine::register_transition()</a></code> and process events with <code><a class="el" href="structst_1_1state_1_1machine.html#aab2fcf9b00f8f7b7aad31ec7e60c4199" title="process_event the state machine an event has occurred">st::state::machine::process_event()</a></code>.</p>
<p>The user can create states by defining classes which inherit <code><a class="el" href="structst_1_1state.html">st::state</a></code>, optionally overriding methods and passing an allocated <code>shared_ptr&lt;<a class="el" href="structst_1_1state.html">st::state</a>&gt;</code> of that class to <code><a class="el" href="structst_1_1state_1_1machine.html#ae2281d9b0422dc3ea4aabe375bab6024" title="Register a state object to be transitioned to when notified of an event.">st::state::machine::register_transition()</a></code>. The function <code><a class="el" href="structst_1_1state.html#ae4ee7ee1d9035c37b4ed5f875c90fad8" title="a convenience function for generating shared_ptr&#39;s to state objects">st::state::make</a>&lt;YourStateType&gt;(/* YourStateType constructor args */)</code> is provided as a convenience for this process.</p>
<div class="fragment"><div class="line">int main() {</div>
<div class="line">    struct conversation {</div>
<div class="line">        enum event {</div>
<div class="line">            partner_speaks,</div>
<div class="line">            you_speak </div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct listening : public st::state {</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            std::cout &lt;&lt; &quot;your partner begins speaking and you listen&quot; &lt;&lt; std::endl;</div>
<div class="line">            // a default (null) shared pointer returned from enter() causes transition to continue normally</div>
<div class="line">            return std::shared_ptr&lt;st::message&gt;(); </div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct talking : public st::state {</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            std::cout &lt;&lt; &quot;you begin speaking and your partner listens&quot; &lt;&lt; std::endl;</div>
<div class="line">            return std::shared_ptr&lt;st::message&gt;();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    auto listening_st = st::state::make&lt;listening&gt;();</div>
<div class="line">    auto talking_st = st::state::make&lt;talking&gt;();</div>
<div class="line">    auto conversation_machine = st::state::machine::make();</div>
<div class="line"> </div>
<div class="line">    // register the state transitions </div>
<div class="line">    conversation_machine-&gt;register_transition(conversation::event::partner_speaks, listening_st);</div>
<div class="line">    conversation_machine-&gt;register_transition(conversation::event::you_speak, talking_st);</div>
<div class="line"> </div>
<div class="line">    // set the initial machine state </div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::partner_speaks);</div>
<div class="line"> </div>
<div class="line">    // have a conversation</div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::you_speak); </div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::partner_speaks); </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">your partner begins speaking and you listen</div>
<div class="line">you begin speaking and your partner listens</div>
<div class="line">your partner begins speaking and you listen</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Replacing switch statements with state machines</h3>
<p>Since function signatures <code>std::shared_ptr&lt;<a class="el" href="structst_1_1message.html" title="Interthread type erased message container.">st::message</a>&gt; <a class="el" href="structst_1_1state.html#a740834a32ddfdf58105f00d6d9bccacf" title="called during a transition when a state is entered">st::state::enter</a>(std::shared_ptr&lt;<a class="el" href="structst_1_1message.html" title="Interthread type erased message container.">st::message</a>&gt;)</code> and <code>bool <a class="el" href="structst_1_1state.html#a450771b125b1a1ba9b3ccc2dc07b959c" title="called during a transition when a state is exitted">st::state::exit</a>(std::shared_ptr&lt;<a class="el" href="structst_1_1message.html" title="Interthread type erased message container.">st::message</a>&gt;)</code> accept a message object as their arguments, the user can directly replace <code>switch</code> statements from within <code><a class="el" href="structst_1_1worker.html" title="Managed system worker thread.">st::worker</a></code> instances with calls to <code><a class="el" href="structst_1_1state_1_1machine.html#aab2fcf9b00f8f7b7aad31ec7e60c4199" title="process_event the state machine an event has occurred">st::state::machine::process_event()</a></code> if desired. </p><div class="fragment"><div class="line">int main() {</div>
<div class="line">    struct conversation_worker {</div>
<div class="line">        enum op {</div>
<div class="line">            partner_speaks,</div>
<div class="line">            you_speak </div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        struct listening : public st::state {</div>
<div class="line">            std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">                std::string s;</div>
<div class="line">                event-&gt;copy_data_to(s);</div>
<div class="line">                std::cout &lt;&lt; &quot;your partner speaks: &quot; &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">                return std::shared_ptr&lt;st::message&gt;();</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        struct talking : public st::state {</div>
<div class="line">            std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">                std::string s;</div>
<div class="line">                event-&gt;copy_data_to(s);</div>
<div class="line">                std::cout &lt;&lt; &quot;you speak: &quot; &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">                return std::shared_ptr&lt;st::message&gt;();</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        conversation_worker() { </div>
<div class="line">            auto listening_st = st::state::make&lt;listening&gt;();</div>
<div class="line">            auto talking_st = st::state::make&lt;talking&gt;();</div>
<div class="line">            m_machine = st::state::machine::make();</div>
<div class="line"> </div>
<div class="line">            // register the state transitions </div>
<div class="line">            m_machine-&gt;register_transition(conversation_worker::op::partner_speaks, listening_st);</div>
<div class="line">            m_machine-&gt;register_transition(conversation_worker::op::you_speak, talking_st);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        inline void operator()(std::shared_ptr&lt;st::message&gt; msg) {</div>
<div class="line">            m_machine-&gt;process_event(msg);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        std::shared_ptr&lt;st::state::machine&gt; m_machine;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    // launch a worker thread to utilize the state machine</div>
<div class="line">    auto wkr = st::worker::make&lt;conversation_worker&gt;();</div>
<div class="line"> </div>
<div class="line">    // set the initial machine state and begin handling events</div>
<div class="line">    wkr-&gt;send(conversation_worker::op::partner_speaks, std::string(&quot;hello foo&quot;));</div>
<div class="line">    wkr-&gt;send(conversation_worker::op::you_speak, std::string(&quot;hello faa&quot;)); </div>
<div class="line">    wkr-&gt;send(conversation_worker::op::partner_speaks, std::string(&quot;goodbye foo&quot;)); </div>
<div class="line">    wkr-&gt;send(conversation_worker::op::you_speak, std::string(&quot;goodbye faa&quot;)); </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">your partner speaks: hello foo</div>
<div class="line">you speak: hello faa</div>
<div class="line">your partner speaks: goodbye foo</div>
<div class="line">you speak: goodbye faa</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
Implementing state transition guards</h3>
<p>The user can implement transition guards and prevent transitioning away from a state by overriding the <code>bool <a class="el" href="structst_1_1state.html#a450771b125b1a1ba9b3ccc2dc07b959c" title="called during a transition when a state is exitted">st::state::exit</a>(std::shared_ptr&lt;<a class="el" href="structst_1_1message.html" title="Interthread type erased message container.">st::message</a>&gt;)</code> method, where the state will only transition if that function returns <code>true</code>. </p><div class="fragment"><div class="line">int main() {</div>
<div class="line">    struct conversation {</div>
<div class="line">        enum event {</div>
<div class="line">            partner_speaks,</div>
<div class="line">            you_speak </div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct listening : public st::state {</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            std::string s;</div>
<div class="line">            event-&gt;copy_data_to(s);</div>
<div class="line">            std::cout &lt;&lt; &quot;your partner speaks: &quot; &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">            return std::shared_ptr&lt;st::message&gt;();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        bool exit(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            // standard guard preventing transitioning to the same event as we are leaving</div>
<div class="line">            if(event-&gt;id() != conversation::event::partner_speaks) {</div>
<div class="line">                return true;</div>
<div class="line">            } else {</div>
<div class="line">                return false;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct talking : public st::state {</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            std::string s;</div>
<div class="line">            event-&gt;copy_data_to(s);</div>
<div class="line">            std::cout &lt;&lt; &quot;you speak: &quot; &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">            return std::shared_ptr&lt;st::message&gt;();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        bool exit(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            // standard guard preventing transitioning to the same event as we are leaving</div>
<div class="line">            if(event-&gt;id() != conversation::event::you_speak) {</div>
<div class="line">                return true;</div>
<div class="line">            } else {</div>
<div class="line">                return false;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    auto listening_st = st::state::make&lt;listening&gt;();</div>
<div class="line">    auto talking_st = st::state::make&lt;talking&gt;();</div>
<div class="line">    auto conversation_machine = st::state::machine::make();</div>
<div class="line"> </div>
<div class="line">    // register the state transitions </div>
<div class="line">    conversation_machine-&gt;register_transition(conversation::event::partner_speaks, listening_st);</div>
<div class="line">    conversation_machine-&gt;register_transition(conversation::event::you_speak, talking_st);</div>
<div class="line"> </div>
<div class="line">    // set the initial machine state and begin handling events (duplicate events </div>
<div class="line">    // will be ignored)</div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::partner_speaks, std::string(&quot;hello foo&quot;)); </div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::partner_speaks, std::string(&quot;hello foo2&quot;)); </div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::partner_speaks, std::string(&quot;hello foo3&quot;));</div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::you_speak, std::string(&quot;hello faa&quot;)); </div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::you_speak, std::string(&quot;hello faa2&quot;)); </div>
<div class="line">    conversation_machine-&gt;process_event(conversation::event::you_speak, std::string(&quot;hello faa3&quot;)); </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">your partner speaks: hello foo</div>
<div class="line">you speak: hello faa</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Processing subsequent events directly from the result of a state transition</h3>
<p>If an implementation of <code><a class="el" href="structst_1_1state.html#a740834a32ddfdf58105f00d6d9bccacf" title="called during a transition when a state is entered">st::state::enter()</a></code> returns a non-null <code>std::shared_ptr&lt;<a class="el" href="structst_1_1message.html" title="Interthread type erased message container.">st::message</a>&gt;</code> that message will be handled as if <code><a class="el" href="structst_1_1state_1_1machine.html#aab2fcf9b00f8f7b7aad31ec7e60c4199" title="process_event the state machine an event has occurred">st::state::machine::process_event()</a></code> had been called with that message as its argument. This allows states to directly transition to other states if necessary: </p><div class="fragment"><div class="line">int main() {</div>
<div class="line">    struct events {</div>
<div class="line">        enum op {</div>
<div class="line">            event1,</div>
<div class="line">            event2,</div>
<div class="line">            event3</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct state1 : public st::state {</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            std::cout &lt;&lt; &quot;state1&quot; &lt;&lt; std::endl;</div>
<div class="line">            return st::message::make(events::event2);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct state2 : public st::state {</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            std::cout &lt;&lt; &quot;state2&quot; &lt;&lt; std::endl;</div>
<div class="line">            return st::message::make(events::event3);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    struct state3 : public st::state {</div>
<div class="line">        std::shared_ptr&lt;st::message&gt; enter(std::shared_ptr&lt;st::message&gt; event) {</div>
<div class="line">            std::cout &lt;&lt; &quot;state3&quot; &lt;&lt; std::endl;</div>
<div class="line">            return std::shared_ptr&lt;st::message&gt;();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    auto sm = st::state::machine::make();</div>
<div class="line">    sm-&gt;register_transition(events::event1, st::state::make&lt;state1&gt;(reached_state1));</div>
<div class="line">    sm-&gt;register_transition(events::event2, st::state::make&lt;state2&gt;(reached_state2));</div>
<div class="line">    sm-&gt;register_transition(events::event3, st::state::make&lt;state3&gt;(reached_state3));</div>
<div class="line"> </div>
<div class="line">    sm-&gt;process_event(events::event1);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">state1</div>
<div class="line">state2</div>
<div class="line">state3</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
