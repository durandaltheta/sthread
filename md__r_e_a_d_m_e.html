<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: Simple C++ Threading and Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Simple C++ Threading and Communication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md2"></a>
Quick Links</h1>
<p>The overall design of code in this library relies heavily on virtual interfaces to implement inherited behavior. Visit the documentation for information and features not detailed in this README.</p>
<p><a href="https://durandaltheta.github.io/sthread/annotated.html">Documentation</a></p>
<p><a href="tst/">Unit Test and Example Code</a></p>
<p><a href="#simple-message-passing">Simple Message Passing</a></p>
<p><a href="#a-closer-look-at-channel-send-operations">A Closer Look at Channel Send Operations</a></p>
<p><a href="#message-data-payloads">Message Data Payloads</a></p>
<p><a href="#payload-data-type-checking">Payload Data Type Checking</a></p>
<p><a href="#object-lifecycles">Object Lifecycles</a></p>
<p><a href="#closing-channels">Closing Channels</a></p>
<p><a href="#abstracting-message-replies">Abstracting Message Replies</a></p>
<p><a href="#dealing-with-blocking-functions">Dealing with Blocking Functions</a></p>
<p><a href="#scheduling-functions-on-user-threads">Scheduling Functions on User Threads</a></p>
<p><a href="#interprocess-considerations">Interprocess Considerations</a></p>
<h1><a class="anchor" id="autotoc_md3"></a>
Purpose</h1>
<p>This library's purpose is to simplify setting up useful c++ threading, and to enable trivial inter-thread message passing of C++ objects. That is, message passing with support for proper C++ construction and destruction instead of blind <code>memcpy()</code> calls, allowing C++ objects to be passed around.</p>
<p>The library provides a handful of objects which support this goal:</p><ul>
<li><code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code></li>
<li><code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code></li>
<li><code><a class="el" href="structst_1_1reply.html" title="object capable of sending a st::message back to an st::channel">st::reply</a></code></li>
<li><code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code></li>
</ul>
<p>The core of the behavior of the library is tied to the <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> object, which is responsible for asynchronously sending messages between senders and receivers. A receiver thread can use this object to make a simple message receive loop and process incoming <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code>s.</p>
<p>Each of the above objects is actually a thinly wrapped shared pointer to some internal data. The internal data must be constructed by a call to that object's associated static <code>make()</code> method. This means that once these objects are constructed, they can be passed around efficiently like any other variable. In the case of <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> all of its public methods are threadsafe.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Requirements</h1>
<ul>
<li>C++11 compatible compiler toolchain</li>
<li>make</li>
<li>cmake</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
Git Submodules</h1>
<p>This project uses Googletest as a submodule to build unit tests. If unit tests are needed try cloning this project with submodules:</p><ul>
<li>git clone &ndash;recurse-submodules <a href="https://github.com/durandaltheta/sthread">https://github.com/durandaltheta/sthread</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Installation</h1>
<ul>
<li><code>cmake .</code></li>
<li><code>make install</code></li>
</ul>
<p>If building on linux, may have to <code>sudo make install</code>.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Build Unit Tests</h1>
<ul>
<li><code>cmake .</code></li>
<li><code>make sthread_tst</code></li>
</ul>
<p><code>sthread_tst</code> binary will be placed in directory <code>tst/</code></p>
<h1><a class="anchor" id="autotoc_md8"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Simple message passing</h2>
<p>All that is required to send/receive messages between threads is that each thread has a copy of a constructed <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> object. Messages can be sent with a call to <code>bool st::channel::send(...)</code> and messages can be received by calling <code>bool <a class="el" href="structst_1_1channel.html#a6a14871912401c4b59f16594eef809b1" title="receive a message over the channel">st::channel::recv(st::message&amp; msg)</a></code>. However, the simplest message receive solution is to make use of <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> iterators in a range-for loop. <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> iterators can also be returned with calls to <code><a class="el" href="structst_1_1channel.html#a01d46295d248d7848c7156e43d27e1e5">st::channel::begin()</a></code> and <code><a class="el" href="structst_1_1channel.html#a0173fc4b0b49246bb6c2aa4ab865a270">st::channel::end()</a></code>.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Example</h3>
<p><a href="tst/message_passing_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">enum op {</div>
<div class="line">    say, // print an std::string</div>
<div class="line">    goodbye // print a goodbye message</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">st::channel ch = st::channel::make();</div>
<div class="line"> </div>
<div class="line">void childThread() {</div>
<div class="line">    for(auto msg : ch) { // msg is an `st::message`</div>
<div class="line">        switch(msg.id()) {</div>
<div class="line">            case op::say: </div>
<div class="line">                {</div>
<div class="line">                    std::string s;</div>
<div class="line">                    if(msg.data().copy_to(s)) { </div>
<div class="line">                        std::cout &lt;&lt; &quot;child thread says: &quot; &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                break;</div>
<div class="line">            case op::goodbye:</div>
<div class="line">                std::cout &lt;&lt; &quot;Thanks for all the fish!&quot; &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::thread thd(childThread);</div>
<div class="line">    ch.send(op::say, std::string(&quot;hello&quot;));</div>
<div class="line">    ch.send(op::say, std::string(&quot;world&quot;));</div>
<div class="line">    ch.send(op::goodbye);</div>
<div class="line">    ch.close();</div>
<div class="line">    thd.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">child thread says: hello</div>
<div class="line">child thread says: world</div>
<div class="line">Thanks for all the fish!</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
A Closer Look at Channel Send Operations</h2>
<p>Arguments passed to <code>st::channel::send(...)</code> are internally passed to <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> st::message::make(...)</code> function before sending to its destination. <code>st::message::make(...)</code> will generate an allocated <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code> object which contains message identification and an optional data payload.</p>
<p>The summary of the 4 overloads of <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> st::message::make(...)</code> are:</p>
<ul>
<li><code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> <a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> st::message::make(ID id)</code>: Returns a constructed message which returns argument unsigned integer <code>id</code> as <code><a class="el" href="structst_1_1message.html#ad670deed5c6f87c3d6e8463f7fd273b2" title="an unsigned integer representing message&#39;s intended operation">st::message::id()</a></code>. This message has no payload.</li>
<li><code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> <a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> st::message::make(ID id, T&amp;&amp; t)</code>: Same as the previous invocation but additionally accepts and stores a payload <code>t</code> of any type (compiler deduced) <code>T</code>. The will be stored in the message as a type erased <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code>.</li>
<li><code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> <a class="el" href="structst_1_1message.html#a0cee5a2e9f6429ebaa0fe73304b80df1" title="construct a message">st::message::make()</a></code>: Returns a default allocated <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code>. This message has an id of 0 and no payload.</li>
<li><code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a> <a class="el" href="structst_1_1message.html#ad97a780bc24dd0f4d5fe20b193a9d9e7" title="convenience function for templating">st::message::make(st::message)</a></code>: Returns its argument immediately with no changes</li>
</ul>
<p><code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code>s have 2 important methods:</p><ul>
<li><code>std::size_t <a class="el" href="structst_1_1message.html#ad670deed5c6f87c3d6e8463f7fd273b2" title="an unsigned integer representing message&#39;s intended operation">st::message::id()</a></code>: Return the unsigned integer id value stored in the message</li>
<li><code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a>&amp; <a class="el" href="structst_1_1message.html#ae2e78ac509a3c971cdd5f7a82d4d2625" title="optional type erased payload data">st::message::data()</a></code>: Return a reference to the payload <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> stored in the message</li>
</ul>
<p>It should be noted that the <code>auto</code> keyword can be used for objects contructed by <code>make()</code> calls.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Message Data Payloads</h2>
<p><code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data()</a></code> can store any data type. Usually the user will not need to manually construct <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data()</a></code>, as <code>st::message::make(...)</code> methods do this internally. In the cases where manual construction is necessary <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> objects can be constructed with a call to <code><a class="el" href="structst_1_1data.html#afe1ea2c7dd24d9c54c7133ce1405f482" title="construct a data payload using explicit template typing instead of by deduction">st::data::make</a>&lt;T&gt;(optional_constructor_args...)</code>, where type <code>T</code> is the type to be stored in the result <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code>.</p>
<p><code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> objects are thin wrappers to <code>std::unique_ptr&lt;T&gt;</code> objects, and therefore cannot be lvalue copied (ownership between <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> objects must be assigned with <code>destination_data = std::move(source_data)</code>).</p>
<p>The value stored in an <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> can be copied to an argument of templated type <code>T</code> with <code><a class="el" href="structst_1_1data.html#a88b7ca6d8a91f7bb411d505b02519030" title="copy the data payload to argument t">st::data::copy_to(T&amp; t)</a></code> or rvalue swapped with <code><a class="el" href="structst_1_1data.html#acc1ba9d77b2eee7671f266d0bfb69789" title="rvalue swap the data payload to argument t">st::data::move_to(T&amp; t)</a></code>. Said functions will return <code>true</code> if their argument <code>T</code> matches the type <code>T</code> originally stored in the <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code>, otherwise they will return <code>false</code>.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Example</h3>
<p><a href="tst/message_payloads_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">enum op {</div>
<div class="line">    print</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void my_function(st::channel ch) {</div>
<div class="line">    for(auto msg : ch) {</div>
<div class="line">        switch(msg.id()) {</div>
<div class="line">            case op::print:</div>
<div class="line">            {</div>
<div class="line">                std::string s;</div>
<div class="line">                if(msg.data().copy_to(s)) {</div>
<div class="line">                    std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">                } else {</div>
<div class="line">                    std::cout &lt;&lt; &quot;message data was not a string&quot; &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line">                break;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto my_channel = st::channel::make();</div>
<div class="line">    std::thread my_thread(my_function, my_channel);</div>
<div class="line"> </div>
<div class="line">    my_channel.send(op::print, std::string(&quot;hello again&quot;));</div>
<div class="line">    my_channel.send(op::print, 14);</div>
<div class="line">    my_channel.close();</div>
<div class="line">    my_thread.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">hello again</div>
<div class="line">message data was not a string</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Payload Data Type Checking</h2>
<p>Payload <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> types can also be checked with <code>bool <a class="el" href="structst_1_1data.html#aa8ee8dbbd7169b8cdc2d846095d480d5" title="determine at runtime whether the type erased data type code matches the templated type code.">st::data::is</a>&lt;T&gt;()</code> (returns <code>true</code> if types match, else <code>false</code>) which is useful if a message's data might contain several different potential types. If <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> is unallocated then <code><a class="el" href="structst_1_1data.html#aa8ee8dbbd7169b8cdc2d846095d480d5" title="determine at runtime whether the type erased data type code matches the templated type code.">st::data::is</a>&lt;T&gt;()</code> will always return <code>false</code> (<code>st::data::operator bool()</code> conversion will also be <code>false</code>).</p>
<p>Additionally, the type stored in <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> can be cast to a reference with a call to <code>T&amp; <a class="el" href="structst_1_1data.html#ad4c439d0b52b1dc8c0706b25ba21e058" title="cast message data payload to templated type reference">st::data::cast_to</a>&lt;T&gt;()</code>. However, this functionality is only safe when used inside of an <code><a class="el" href="structst_1_1data.html#aa8ee8dbbd7169b8cdc2d846095d480d5" title="determine at runtime whether the type erased data type code matches the templated type code.">st::data::is</a>&lt;T&gt;()</code> check.</p>
<p>WARNING:</p>
<p><code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> can store a payload of any type. However, this behavior can be confusing with regard to c-style <code>const char*</code> strings. c-style strings are just pointers to memory, and the user is responsible for ensuring that said memory is accessible outside of the scope when the message is sent.</p>
<p>Typically, it is safe to send c-style strings with a hardcoded value, as such strings are stored in the program's global data. However, local stack arrays of characters, or, even worse, allocated c-strings must be carefully considered when sending over a message.</p>
<p>Furthermore, compiler rules around array and pointer conversions may sometimes cause unexpected types to be stored in <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> if the type is not explicit. Therefore when using raw c-strings it may be a necessary to explicitly cast it to the expected type whenever assigning a payload to an <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code>: <code><a class="el" href="structst_1_1message.html#ad97a780bc24dd0f4d5fe20b193a9d9e7" title="convenience function for templating">st::message::make</a>(my_id, (const char*)"my string")</code>.</p>
<p>A simple workaround to these headaches is to encapsulate c-style strings within a c++ <code>std::string</code>, which will make typing consistent and explicit.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Example</h3>
<p><a href="tst/payload_data_type_checking_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">enum op {</div>
<div class="line">    print</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void my_function(st::channel ch) {</div>
<div class="line">    for(auto msg : ch) {</div>
<div class="line">        switch(msg.id()) {</div>
<div class="line">            case op::print:</div>
<div class="line">                if(msg.data().is&lt;std::string&gt;()) {</div>
<div class="line">                    std::cout &lt;&lt; msg.data().cast_to&lt;std::string&gt;();</div>
<div class="line">                } else if(msg.data().is&lt;int&gt;()) {</div>
<div class="line">                    std::cout &lt;&lt; msg.data().cast_to&lt;int&gt;();</div>
<div class="line">                }</div>
<div class="line">                break;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto ch = st::channel::make();</div>
<div class="line">    std::thread thd(my_function, ch);</div>
<div class="line"> </div>
<div class="line">    ch.send(op::print, std::string(&quot;hello &quot;));</div>
<div class="line">    ch.send(op::print, 1);</div>
<div class="line">    ch.send(op::print, std::string(&quot; more time\n&quot;));</div>
<div class="line">    ch.close();</div>
<div class="line">    thd.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">hello 1 more time</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Object Lifecycles</h2>
<p>The objects in this library are actually shared pointers to some shared context, whose context needs to be allocated with a static call to their respective <code>make()</code> functions. Objects in this category include:</p><ul>
<li><code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code></li>
<li><code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code></li>
<li><code><a class="el" href="structst_1_1reply.html" title="object capable of sending a st::message back to an st::channel">st::reply</a></code></li>
<li><code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code></li>
</ul>
<p>The user can check if these objects contain an allocated shared context with their <code>bool</code> conversion. This is easiest to do by using the object as the argument to an <code>if()</code> statement. Given an <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> named <code>my_channel</code>: </p><div class="fragment"><div class="line">if(my_channel) {</div>
<div class="line">    // my_channel is allocated</div>
<div class="line">} else {</div>
<div class="line">    // my_channel is not allocated</div>
<div class="line">}</div>
</div><!-- fragment --><p>Attempting to use API of these objects when they are <em>NOT</em> allocated (other than static allocation functions or the <code>bool</code> conversion) will typically result in a failure return value of <code>false</code>. Alternatively, a successful call will return <code>true</code>. This means that users generally don't need to handle exceptions, but they do need to pay attention to return values of methods.</p>
<p>When the last object holding a copy of some shared context goes out of scope, that object will be neatly shutdown and be destroyed. As such, the user is responsible for keeping copies of the above objects when they are created with an allocator function (<code>make()</code>), otherwise they may unexpectedly shutdown.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Closing Channels</h2>
<p>Operations on <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code>'s shared context can be shutdown early with a call to <code>close()</code>, causing operations which use that shared context to fail.</p>
<p>For example, the default behavior for <code><a class="el" href="structst_1_1channel.html#a569ae1a23f523975df09e541485a0475" title="st::channel is set to the closed state">st::channel::close()</a></code> is to cause all current and future all <code><a class="el" href="structst_1_1channel.html#af2979fdcf0cb337e9db495481fd6a478" title="send an st::message with given parameters into the internal message queue">st::channel::send()</a></code> operations to fail early but to allow <code><a class="el" href="structst_1_1channel.html#a6a14871912401c4b59f16594eef809b1" title="receive a message over the channel">st::channel::recv()</a></code> to continue succeeding until the internal message queue is empty. Alternatively, the user can specify a "hard" close by calling <code>st::channel::close(false)</code> to immediately end all send and recieve operations on the object, though this is rarely the preferred behavior.</p>
<p>The user can call <code>bool closed()</code>on these objects to check if an object has been closed or is still running.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Example</h3>
<p><a href="tst/closing_channels_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">void looping_recv(st::channel ch) {</div>
<div class="line">    st::message msg;</div>
<div class="line"> </div>
<div class="line">    // it is possible to manually receive values instead of through iterators</div>
<div class="line">    while(ch.recv(msg)) {</div>
<div class="line">        std::string s;</div>
<div class="line">        if(msg.data().copy_to(s)) {</div>
<div class="line">            std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto my_channel = st::channel::make();</div>
<div class="line">    std::thread my_thread(looping_recv, my_channel);</div>
<div class="line"> </div>
<div class="line">    my_channel.send(0, std::string(&quot;you say goodbye&quot;));</div>
<div class="line">    my_channel.send(0, std::string(&quot;and I say hello&quot;));</div>
<div class="line">    // close channel and join thread</div>
<div class="line">    my_channel.close();</div>
<div class="line">    my_thread.join(); </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">you say goodbye</div>
<div class="line">and I say hello</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Abstracting Message Replies</h2>
<p>Dealing with enumerations when message passing can be complicated when API grows large and painful when enumerations conflict with each other. This typically requires abstraction between multiple APIs such that multiple points in the program do not know anything about the other.</p>
<p>As a convenience, the user can create an <code><a class="el" href="structst_1_1reply.html" title="object capable of sending a st::message back to an st::channel">st::reply</a></code> object to abstract sending a response back over an <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> which hides information about the receiver, simplifying request/response API.</p>
<p><code>st::reply::make(...)</code> will take an <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> and an unsigned integer <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code> id. When <code>st::reply::send(T t)</code> is called, an <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code> containing the given <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code> id and an optional payload <code>t</code> is sent to the stored <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code>.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Example</h3>
<p><a href="tst/abstracting_message_replies_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">enum opA {</div>
<div class="line">    request_value = 0 // send a value back to a requestor</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">enum opB {</div>
<div class="line">    // same enumeration value as opA::request_value, normally a potential bug</div>
<div class="line">    receive_value = 0 </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void childThreadA(st::channel ch) {</div>
<div class="line">    std::string value = &quot;foofaa&quot;;</div>
<div class="line"> </div>
<div class="line">    for(auto msg : ch) {</div>
<div class="line">        switch(msg.id()) {</div>
<div class="line">            case opA::request_value:</div>
<div class="line">            {</div>
<div class="line">                // this thread doesn&#39;t know anything about who they are replying to</div>
<div class="line">                if(msg.data().is&lt;st::reply&gt;()) {</div>
<div class="line">                    msg.data().cast_to&lt;st::reply&gt;().send(value);</div>
<div class="line">                }</div>
<div class="line">                break;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void childThreadB(st::channel ch, st::channel value_received_conf_ch) {</div>
<div class="line">    for(auto msg : ch) {</div>
<div class="line">        switch(msg.id()) {</div>
<div class="line">            // this thread doesn&#39;t know who they are receiving from </div>
<div class="line">            case opB::receive_value:</div>
<div class="line">            {</div>
<div class="line">                std::string s;</div>
<div class="line">                if(msg.data().copy_to(s)) {</div>
<div class="line">                    std::cout &lt;&lt; &quot;received &quot; &lt;&lt; s &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</div>
<div class="line">                    value_received_conf_ch.send();</div>
<div class="line">                }</div>
<div class="line">                break;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // launch child threads</div>
<div class="line">    auto ch_a = st::channel::make(); </div>
<div class="line">    std::thread thd_a(childThreadA, ch_a);</div>
<div class="line"> </div>
<div class="line">    auto ch_b = st::channel::make(); </div>
<div class="line">    auto value_received_conf_ch = st::channel::make(); </div>
<div class="line">    std::thread thd_b(childThreadB, ch_b, value_received_conf_ch);</div>
<div class="line"> </div>
<div class="line">    // create an `st::reply` to forward a value to `ch_b`</div>
<div class="line">    auto rep_b = st::reply::make(ch_b, opB::receive_value);</div>
<div class="line"> </div>
<div class="line">    // send the request for a value over `ch_a`</div>
<div class="line">    ch_a.send(opA::request_value, rep_b);</div>
<div class="line"> </div>
<div class="line">    // wait for childThreadB to process the response from childThreadA </div>
<div class="line">    st::message msg;</div>
<div class="line">    value_received_conf_ch.recv(msg); </div>
<div class="line"> </div>
<div class="line">    // close and join child threads </div>
<div class="line">    ch_a.close();</div>
<div class="line">    ch_b.close();</div>
<div class="line">    thd_a.join();</div>
<div class="line">    thd_b.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">received foofaa!</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Dealing with Blocking Functions</h2>
<p>To ensure messages are processed in a timely manner, and to avoid deadlock in general, it is important to avoid calling functions which will block for indeterminate periods within a message receiving thread. If the user needs to call such a function a solution is to make use of the standard library's <code>std::async()</code> feature to execute arbitrary code on a separate, dedicated system thread, then <code>send()</code> the result back to through the caller's <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> when the call completes.</p>
<p><code><a class="el" href="structst_1_1channel.html#a0291ed63f29947152463a0cdfe14d9c3" title="asynchronously execute user Callable on a system thread">st::channel::async()</a></code> is provided for exactly this purpose, sending an <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code> back through the channel to a receiver when the scheduled function (actually any <code>Callable</code>) completes. The resulting <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code> will have the same id passed to <code><a class="el" href="structst_1_1channel.html#a0291ed63f29947152463a0cdfe14d9c3" title="asynchronously execute user Callable on a system thread">st::channel::async()</a></code> and the payload will be the return value of the executed function:</p>
<p><code>st::channel::async(std::size_t resp_id, user_function, optional_function_args...)</code></p>
<p>Alternatively, if the user function returns <code>void</code>, the <code><a class="el" href="structst_1_1message.html#ae2e78ac509a3c971cdd5f7a82d4d2625" title="optional type erased payload data">st::message::data()</a></code> will be unallocated (<code>st::data::operator bool()</code> will return <code>false</code>).</p>
<p>The user can implement a simple timer mechanism using this functionality by calling <code>std::this_thread::sleep_for(...)</code> inside of <code>user_function</code>. Another convenience, <code>st::channel::timer(duration, id, optional_payload)</code> does exactly this, where <code>duration</code> is a <code>std::chrono::duration</code> sending <code>id</code> (and potentially a payload) in a <code><a class="el" href="structst_1_1message.html" title="interthread type erased message container">st::message</a></code> over the <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code> after timeout.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Example</h3>
<p><a href="tst/dealing_with_blocking_functions_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;chrono&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">enum op {</div>
<div class="line">    timeout</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// variant of user_timer returning a value</div>
<div class="line">std::string user_timer(std::chrono::milliseconds ms, std::string s) {</div>
<div class="line">    std::this_thread::sleep_for(ms);</div>
<div class="line">    std::cout &lt;&lt; &quot;sleep ended on temporary thread&quot; &lt;&lt; std::endl;</div>
<div class="line">    return s;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// variant of user_timer returning void</div>
<div class="line">void user_timer(std::chrono::milliseconds ms) {</div>
<div class="line">    std::this_thread::sleep_for(ms);</div>
<div class="line">    std::cout &lt;&lt; &quot;sleep ended on temporary thread with no return&quot; &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void process_timeouts(st::channel ch, st::channel timeout_conf_ch) {</div>
<div class="line">    for(auto msg: ch) { </div>
<div class="line">        switch(msg.id()) {</div>
<div class="line">            case op::timeout:</div>
<div class="line">                std::cout &lt;&lt; &quot;timeout detected&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">                if(msg.data().is&lt;std::string&gt;()) {</div>
<div class="line">                    std::cout &lt;&lt; msg.data().cast_to&lt;std::string&gt;() &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                // let main thread know we processed the timeout</div>
<div class="line">                timeout_conf_ch.send(0); </div>
<div class="line">                break;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto ch = st::channel::make();</div>
<div class="line">    auto timeout_conf_ch = st::channel::make();</div>
<div class="line">    std::thread thd(process_timeouts, ch, timeout_conf_ch);</div>
<div class="line"> </div>
<div class="line">    ch.async(op::timeout, </div>
<div class="line">             user_timer, </div>
<div class="line">             std::chrono::milliseconds(100), </div>
<div class="line">             std::string(&quot;that&#39;s all folks!&quot;));</div>
<div class="line"> </div>
<div class="line">    ch.async(op::timeout, user_timer, std::chrono::milliseconds(200));</div>
<div class="line"> </div>
<div class="line">    ch.timer(op::timeout, std::chrono::milliseconds(300), std::string(&quot;timer with payload&quot;));</div>
<div class="line">    ch.timer(op::timeout, std::chrono::milliseconds(400));</div>
<div class="line"> </div>
<div class="line">    // wait for child thread to indicate it received the timeout confirmation</div>
<div class="line">    st::message msg;</div>
<div class="line">    timeout_conf_ch.recv(msg);</div>
<div class="line">    timeout_conf_ch.recv(msg);</div>
<div class="line">    timeout_conf_ch.recv(msg);</div>
<div class="line">    timeout_conf_ch.recv(msg);</div>
<div class="line"> </div>
<div class="line">    ch.close();</div>
<div class="line">    thd.join(); </div>
<div class="line">    return 0; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out</div>
<div class="line">sleep ended on temporary thread</div>
<div class="line">timeout detected</div>
<div class="line">that&#39;s all folks!</div>
<div class="line">sleep ended on temporary thread with no return</div>
<div class="line">timeout detected</div>
<div class="line">timeout detected</div>
<div class="line">timer with payload</div>
<div class="line">timeout detected</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Scheduling Functions on User Threads</h2>
<p>The utility type <code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code> provides the ability to wrap any <code>Callable</code> (and optionally any arguments) for execution.</p>
<p>A <code>Callable</code> is any data or object which can be executed like a function including:</p><ul>
<li>functions</li>
<li>function pointers</li>
<li>functors (ex: <code>std::function</code>)</li>
<li>lambdas</li>
</ul>
<p><code>st::task::make(Callable, optional_arguments...)</code> can be invoked to make a <code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code> which will wrap it's arguments into a task for the user. <code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code> objects can be invoked with the <code>()</code> operator.</p>
<p>When invoked <code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code> objects will return a reference to an <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a></code> value containing the returned value of the wrapped <code>Callable</code>. If wrapped <code>Callable</code> returns void, the resulting <code><a class="el" href="structst_1_1data.html" title="type erased data container">st::data</a>&amp;</code> will be empty and <code>== false</code> when used in an <code>if</code> statement.</p>
<p><code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code> objects are 'lazy', in that once they have been evaluated once, further evaluations will immediately return the previously returned value with no further work.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Example</h3>
<p><a href="tst/scheduling_functions_on_user_threads_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">int foo(int a) {</div>
<div class="line">    std::cout &lt;&lt; &quot;foo: &quot; &lt;&lt; a &lt;&lt; std::endl;</div>
<div class="line">    return a + 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto foo_task = st::task::make(foo, 3);</div>
<div class="line">    if(foo_task().is&lt;int&gt;()) {</div>
<div class="line">        // can safely invoke task again because it will immediately return its</div>
<div class="line">        // previous result</div>
<div class="line">        std::cout &lt;&lt; &quot;result: &quot; &lt;&lt; foo_task().cast_to&lt;int&gt;() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">foo: 3</div>
<div class="line">result: 4</div>
<div class="line">$</div>
</div><!-- fragment --><p><code><a class="el" href="structst_1_1task.html" title="wrap any Callable and optional arguments into an executable task">st::task</a></code>s can be sent over <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code>s to implement arbitrary code execution worker threads:</p>
<h3><a class="anchor" id="autotoc_md25"></a>
Example</h3>
<p><a href="tst/scheduling_functions_on_user_threads_ex.cpp">example source</a> </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line"> </div>
<div class="line">void print(const char* s) {</div>
<div class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct PrintFunctor { </div>
<div class="line">    void operator()(const char* s) {</div>
<div class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void executor(st::channel ch) {</div>
<div class="line">    for(auto msg : ch) { </div>
<div class="line">        // execute any received tasks</div>
<div class="line">        if(msg.data().is&lt;st::task&gt;()) {</div>
<div class="line">            msg.data().cast_to&lt;st::task&gt;()();</div>
<div class="line">        }</div>
<div class="line">    } </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto printer_lambda = []{ std::cout &lt;&lt; &quot;what a beautiful sunset&quot; &lt;&lt; std::endl; };</div>
<div class="line">    auto ch = st::channel::make();</div>
<div class="line">    std::thread thd(executor, ch); </div>
<div class="line"> </div>
<div class="line">    // in this example, message id&#39;s are arbitrary</div>
<div class="line">    ch.send(0, st::task::make(print, &quot;what a beautiful day&quot;));</div>
<div class="line">    ch.send(0, st::task::make(PrintFunctor(), &quot;looks like rain&quot;));</div>
<div class="line">    ch.send(0, st::task::make(printer_lambda));</div>
<div class="line"> </div>
<div class="line">    ch.close();</div>
<div class="line">    thd.join();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Terminal output might be: </p><div class="fragment"><div class="line">$./a.out </div>
<div class="line">what a beautiful day </div>
<div class="line">looks like rain </div>
<div class="line">what a beautiful sunset</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
Interprocess Considerations</h2>
<p>While <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code>s are useful for communicating between a single process's threads, they cannot be used for communicating between processes. A simple method for unifying interprocess and interthread communication is to use one thread as a translator, receiving interprocess messages and forwarding them to a main thread over an <code><a class="el" href="structst_1_1channel.html" title="Interthread message passing queue.">st::channel</a></code>.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Example</h3>
<p>Given this theoretical <code>interprocess_messaging.h</code> API header: </p><div class="fragment"><div class="line">#ifndef INTERPROCESS_MESSAGING</div>
<div class="line">#define INTERPROCESS_MESSAGING</div>
<div class="line"> </div>
<div class="line">#define INTERPROCESS_MESSAGE_BUFFER_SIZE 2048</div>
<div class="line"> </div>
<div class="line">struct interprocess_message {</div>
<div class="line">    ssize_t id; // message id</div>
<div class="line">    char buffer[INTERPROCESS_MESSAGE_BUFFER_SIZE]; // buffer filled by receive function  </div>
<div class="line">    ssize_t size; // payload data size</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">enum INTERPROCESS_ERRORS {</div>
<div class="line">    SUCCESS = 0,</div>
<div class="line">    // ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Type HANDLE is some value used by the interprocess mechanism for identifying</div>
<div class="line">// and differentiating queues and endpoints. </div>
<div class="line">typedef int HANDLE;</div>
<div class="line"> </div>
<div class="line">extern int interprocess_open_queue(const char* queue_name, HANDLE* hdl);</div>
<div class="line">extern int interprocess_send_message(HANDLE queue, message* msg);</div>
<div class="line">extern int interprocess_recv_message(HANDLE queue, message* msg);</div>
<div class="line">extern int interprocess_close_queue(HANDLE);</div>
<div class="line">#endif</div>
</div><!-- fragment --><p>With the user's <code>my_public_api.h</code> API header for interprocess communication: </p><div class="fragment"><div class="line">#ifndef MY_PUBLIC_API</div>
<div class="line">#define MY_PUBLIC_API</div>
<div class="line">const char* INTERPROCESS_QUEUE_NAME = &quot;my_interprocess_queue_name&quot;</div>
<div class="line"> </div>
<div class="line">enum my_public_api {</div>
<div class="line">    INTERPROCESS_OPERATION_1 = 0,</div>
<div class="line">    INTERPROCESS_OPERATION_2,</div>
<div class="line">    // etc...</div>
<div class="line">    INTERPROCESS_SHUTDOWN,</div>
<div class="line">    MY_PUBLIC_API_RESERVED // do not put values in this enum after this</div>
<div class="line">};</div>
<div class="line">#endif</div>
</div><!-- fragment --><p>And an internal <code>my_api.h</code> API header for interthread communication which extends the message types defined in <code>my_public_api.h</code>: </p><div class="fragment"><div class="line">#ifndef MY_API</div>
<div class="line">#define MY_API</div>
<div class="line">#include  &quot;my_public_api.h&quot;</div>
<div class="line"> </div>
<div class="line">enum my_api {</div>
<div class="line">    // internal operations start on reserved value</div>
<div class="line">    interprocess_receive_error = MY_PUBLIC_API_RESERVED,  </div>
<div class="line">    internal_operation_2,</div>
<div class="line">    // etc...</div>
<div class="line">    internal_operation_n</div>
<div class="line">};</div>
<div class="line">#endif</div>
</div><!-- fragment --><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;sthread&gt;</div>
<div class="line">#include &quot;interprocess_messaging.h&quot;</div>
<div class="line">#include &quot;my_api.h&quot;</div>
<div class="line"> </div>
<div class="line">void interprocess_receive_loop(st::channel ch, HANDLE hdl) {</div>
<div class="line">    int error = 0;</div>
<div class="line">    interprocess_message ipmsg;</div>
<div class="line">    memset(&amp;ipmsg, 0, sizeof(interprocess_message));</div>
<div class="line"> </div>
<div class="line">    // when main thread closes interprocess queue this loop will end</div>
<div class="line">    while(0 == error = interprocess_recv_message(hdl, &amp;ipmsg)) { </div>
<div class="line">        // received interprocess_message will be in the `st::message` payload</div>
<div class="line">        ch.send(msg.id, ipmsg);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if(0 != error) {</div>
<div class="line">        // this will only be handled by the main thread in the case of an </div>
<div class="line">        // unexpected error, not when the main thread caused the error by </div>
<div class="line">        // closing the interprocess queue</div>
<div class="line">        ch.send(my_api::interprocess_receive_error, error);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int ret = 0;</div>
<div class="line">    int error = 0;</div>
<div class="line">    HANDLE hdl;</div>
<div class="line">    auto ch = st::channel::make();</div>
<div class="line"> </div>
<div class="line">    if(0 == error = interprocess_open_queue(INTERPROCESS_QUEUE_NAME, &amp;hdl)) {</div>
<div class="line">        std::thread interprocess_receive_thread(interprocess_receive_loop, ch, hdl);</div>
<div class="line"> </div>
<div class="line">        // launch any other child threads...</div>
<div class="line"> </div>
<div class="line">        // handle incoming messages</div>
<div class="line">        for(auto msg : ch) {</div>
<div class="line">            switch(msg.id()) {</div>
<div class="line">                case INTERPROCESS_OPERATION_1:</div>
<div class="line">                    // ...</div>
<div class="line">                    break;</div>
<div class="line">                case INTERPROCESS_OPERATION_2:</div>
<div class="line">                    // ...</div>
<div class="line">                    break;</div>
<div class="line">                // handle other public API operations...</div>
<div class="line">                case INTERPROCESS_SHUTDOWN:</div>
<div class="line">                    // end message processing and cleanup</div>
<div class="line">                    ch.close(); </div>
<div class="line">                    break;</div>
<div class="line">                // handle private API operations...</div>
<div class="line">                case my_api::interprocess_receive_error:</div>
<div class="line">                    if(msg.data().copy_to(error)) {</div>
<div class="line">                        std::cerr &lt;&lt; &quot;interprocess queue receive failed with error[&quot; &lt;&lt; error &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</div>
<div class="line">                    } else {</div>
<div class="line">                        std::cerr &lt;&lt; &quot;interprocess queue receive failed; message type unknown&quot; &lt;&lt; std::endl;</div>
<div class="line">                    }</div>
<div class="line">                    ret = 1;</div>
<div class="line">                    break;</div>
<div class="line">                case my_api::internal_operation_2:</div>
<div class="line">                    // ...</div>
<div class="line">                    break;</div>
<div class="line">                // ...</div>
<div class="line">                case my_api::internal_operation_n:</div>
<div class="line">                    // ...</div>
<div class="line">                    break;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        // shutdown interprocess queue to end interprocess_receive_thread</div>
<div class="line">        if(0 != error = interprocess_close_queue(hdl)) {</div>
<div class="line">            std::cerr &lt;&lt; &quot;interprocess queue close failed with error[&quot; &lt;&lt; error &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</div>
<div class="line">            ret = 1;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        interprocess_receive_thread.join();</div>
<div class="line"> </div>
<div class="line">        // shutdown and join any other child threads...</div>
<div class="line">    } else {</div>
<div class="line">        std::cerr &lt;&lt; &quot;failed to open interprocess queue[&quot; &lt;&lt; INTERPROCESS_QUEUE_NAME &lt;&lt; &quot;] with error[&quot; &lt;&lt; error &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</div>
<div class="line">        ret = 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return ret;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
