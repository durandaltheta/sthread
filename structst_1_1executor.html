<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: st::executor Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>st</b></li><li class="navelem"><a class="el" href="structst_1_1executor.html">executor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structst_1_1executor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">st::executor Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>a class managing one or more identical worker threads  
 <a href="structst_1_1executor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="simple__thread_8hpp_source.html">simple_thread.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b864199a7f76a4f07e61fe19650e688"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#a0b864199a7f76a4f07e61fe19650e688">running</a> () const</td></tr>
<tr class="separator:a0b864199a7f76a4f07e61fe19650e688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108d5f0f3a5cd584001d4c5822f51d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#a0108d5f0f3a5cd584001d4c5822f51d0">shutdown</a> (bool process_remaining_messages=true)</td></tr>
<tr class="memdesc:a0108d5f0f3a5cd584001d4c5822f51d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the worker threads.  <a href="structst_1_1executor.html#a0108d5f0f3a5cd584001d4c5822f51d0">More...</a><br /></td></tr>
<tr class="separator:a0108d5f0f3a5cd584001d4c5822f51d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf0abd5b804af93c36d48255f0babb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#aaaf0abd5b804af93c36d48255f0babb3">restart</a> (bool process_remaining_messages=true)</td></tr>
<tr class="memdesc:aaaf0abd5b804af93c36d48255f0babb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the worker threads.  <a href="structst_1_1executor.html#aaaf0abd5b804af93c36d48255f0babb3">More...</a><br /></td></tr>
<tr class="separator:aaaf0abd5b804af93c36d48255f0babb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c10abfb9bebc69d210186a1d3c22a01"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#a8c10abfb9bebc69d210186a1d3c22a01">worker_count</a> () const</td></tr>
<tr class="separator:a8c10abfb9bebc69d210186a1d3c22a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d8ab4f64b7b2479e79a11d6c31705f"><td class="memTemplParams" colspan="2">template&lt;typename... As&gt; </td></tr>
<tr class="memitem:ae7d8ab4f64b7b2479e79a11d6c31705f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#ae7d8ab4f64b7b2479e79a11d6c31705f">send</a> (As &amp;&amp;... as)</td></tr>
<tr class="memdesc:ae7d8ab4f64b7b2479e79a11d6c31705f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message over the channel with given @parameters.  <a href="structst_1_1executor.html#ae7d8ab4f64b7b2479e79a11d6c31705f">More...</a><br /></td></tr>
<tr class="separator:ae7d8ab4f64b7b2479e79a11d6c31705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233db22a695c28d7f99429935cdb1e82"><td class="memTemplParams" colspan="2">template&lt;typename... As&gt; </td></tr>
<tr class="memitem:a233db22a695c28d7f99429935cdb1e82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#a233db22a695c28d7f99429935cdb1e82">try_send</a> (As &amp;&amp;... as)</td></tr>
<tr class="memdesc:a233db22a695c28d7f99429935cdb1e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message over the channel with given parameters.  <a href="structst_1_1executor.html#a233db22a695c28d7f99429935cdb1e82">More...</a><br /></td></tr>
<tr class="separator:a233db22a695c28d7f99429935cdb1e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab149bc4c67a451ef8ef0dd6953838c52"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#ab149bc4c67a451ef8ef0dd6953838c52">default_worker_count</a> ()</td></tr>
<tr class="memdesc:ab149bc4c67a451ef8ef0dd6953838c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempt to retrieve a sane executor worker count for maximum CPU throughput  <a href="structst_1_1executor.html#ab149bc4c67a451ef8ef0dd6953838c52">More...</a><br /></td></tr>
<tr class="separator:ab149bc4c67a451ef8ef0dd6953838c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1352603778c6f81089f8541ff87e7b"><td class="memTemplParams" colspan="2">template&lt;typename FUNCTOR , typename... As&gt; </td></tr>
<tr class="memitem:a1e1352603778c6f81089f8541ff87e7b"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structst_1_1executor.html">executor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structst_1_1executor.html#a1e1352603778c6f81089f8541ff87e7b">make</a> (std::size_t <a class="el" href="structst_1_1executor.html#a8c10abfb9bebc69d210186a1d3c22a01">worker_count</a>, As &amp;&amp;... as)</td></tr>
<tr class="memdesc:a1e1352603778c6f81089f8541ff87e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate an executor to manage worker threads  <a href="structst_1_1executor.html#a1e1352603778c6f81089f8541ff87e7b">More...</a><br /></td></tr>
<tr class="separator:a1e1352603778c6f81089f8541ff87e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>a class managing one or more identical worker threads </p>
<p>The <code>executor</code> object implements a constant time algorithm which attempts to efficiently distribute tasks among worker threads.</p>
<p>The <code>executor</code> object is especially useful for scheduling operations which benefit from high CPU throughput and are not reliant on the specific thread upon which they run.</p>
<p>Highest CPU throughput is typically reached by an executor whose worker count matches the CPU core count of the executing machine. This optimal number of cores may be discoverable by the return value of a call to <code><a class="el" href="structst_1_1executor.html#ab149bc4c67a451ef8ef0dd6953838c52" title="attempt to retrieve a sane executor worker count for maximum CPU throughput">st::executor::default_worker_count()</a></code>, though this is not guaranteed.</p>
<p>Because <code>executor</code> manages a limited number of workers, any message whose processing blocks a worker indefinitely can cause all sorts of bad effects, including deadlock. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab149bc4c67a451ef8ef0dd6953838c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab149bc4c67a451ef8ef0dd6953838c52">&#9670;&nbsp;</a></span>default_worker_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t st::executor::default_worker_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>attempt to retrieve a sane executor worker count for maximum CPU throughput </p>
<p>The standard does not enforce the return value of <code>std::thread::hardware_concurrency()</code>, but it typically represents the number of cores a computer has, a number which typically represents the ideal number of threads to allocate for maximum processing throughput.</p>
<dl class="section return"><dt>Returns</dt><dd>maximumly efficient count of worker threads for CPU throughput </dd></dl>

</div>
</div>
<a id="a1e1352603778c6f81089f8541ff87e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1352603778c6f81089f8541ff87e7b">&#9670;&nbsp;</a></span>make()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FUNCTOR , typename... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="structst_1_1executor.html">executor</a>&gt; st::executor::make </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>worker_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">As &amp;&amp;...&#160;</td>
          <td class="paramname"><em>as</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate an executor to manage worker threads </p>
<p>The template type FUNCTOR is the same as used in <code><a class="el" href="structst_1_1worker.html#a4ab1891f3a52bc05871caa1e4f0b55af">st::worker::make</a>&lt;FUNCTOR&gt;(constructor args...)</code>, allowing the user to design and specify any FUNCTOR they please. However, in many cases the user can simply use <code><a class="el" href="structst_1_1processor.html" title="convenience functor class definition for generic asynchronous code execution">st::processor</a></code> as the templated type, as that functor definition is designed for processing generic operations.</p>
<p>An intelligent value for worker_count can typically be retrieved from <code><a class="el" href="structst_1_1executor.html#ab149bc4c67a451ef8ef0dd6953838c52" title="attempt to retrieve a sane executor worker count for maximum CPU throughput">default_worker_count()</a></code> if maximum CPU throughput is desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_count</td><td>the number of threads this executor should manage </td></tr>
    <tr><td class="paramname">as</td><td>constructor arguments for type FUNCTOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated running worker thread shared_ptr </dd></dl>

</div>
</div>
<a id="aaaf0abd5b804af93c36d48255f0babb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf0abd5b804af93c36d48255f0babb3">&#9670;&nbsp;</a></span>restart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void st::executor::restart </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>process_remaining_messages</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart the worker threads. </p>
<p>Shutdown threads and reset state when necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_remaining_messages</td><td>if true allow recv() to succeed until queue empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b864199a7f76a4f07e61fe19650e688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b864199a7f76a4f07e61fe19650e688">&#9670;&nbsp;</a></span>running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool st::executor::running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if executor's worker threads are running, else false </dd></dl>

</div>
</div>
<a id="ae7d8ab4f64b7b2479e79a11d6c31705f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d8ab4f64b7b2479e79a11d6c31705f">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool st::executor::send </td>
          <td>(</td>
          <td class="paramtype">As &amp;&amp;...&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message over the channel with given @parameters. </p>
<p>This is a blocking operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>argument(s) to <code><a class="el" href="structst_1_1message.html#af3bfc649bfad36dca05f901fe31c5066" title="convenience function for templating">st::message::make()</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structst_1_1result.html#aa80f6879a068bcfe66860e43e3ecc275">result.status</a>==result::eStatus::success on success, <a class="el" href="structst_1_1result.html#aa80f6879a068bcfe66860e43e3ecc275">result.status</a>==result::eStatus::closed if closed </dd></dl>

</div>
</div>
<a id="a0108d5f0f3a5cd584001d4c5822f51d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0108d5f0f3a5cd584001d4c5822f51d0">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void st::executor::shutdown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>process_remaining_messages</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdown the worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_remaining_messages</td><td>if true allow recv() to succeed until queue empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a233db22a695c28d7f99429935cdb1e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233db22a695c28d7f99429935cdb1e82">&#9670;&nbsp;</a></span>try_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... As&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool st::executor::try_send </td>
          <td>(</td>
          <td class="paramtype">As &amp;&amp;...&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message over the channel with given parameters. </p>
<p>This is a non-blocking operation. If queue is full, operation will fail early.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>an unsigned integer representing which type of message </td></tr>
    <tr><td class="paramname">as</td><td>additional argument(s) to <code><a class="el" href="structst_1_1message.html#af3bfc649bfad36dca05f901fe31c5066" title="convenience function for templating">st::message::make()</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structst_1_1result.html#aa80f6879a068bcfe66860e43e3ecc275">result.status</a>==result::eStatus::success on success, <a class="el" href="structst_1_1result.html#aa80f6879a068bcfe66860e43e3ecc275">result.status</a>==result::eStatus::closed if closed, <a class="el" href="structst_1_1result.html#aa80f6879a068bcfe66860e43e3ecc275">result.status</a>==result::eStatus::full if full </dd></dl>

</div>
</div>
<a id="a8c10abfb9bebc69d210186a1d3c22a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c10abfb9bebc69d210186a1d3c22a01">&#9670;&nbsp;</a></span>worker_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t st::executor::worker_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of worker threads managed by this executor </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>inc/<a class="el" href="simple__thread_8hpp_source.html">simple_thread.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
